<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>从998244353开始的筛法教程</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="从998244353开始的数论函数筛法教程">从998244353开始的数论函数筛法教程</h1>
<p><strong><em>notice</em></strong></p>
<ul>
<li>本文内容源于hehelego/spinach的笔记/讲稿/校内研学报告,部分内容参考了网络资料(包括但不限于wikipedia词条,OI集训队论文集,神仙们的blog和 <em>concrete mathematics</em>)</li>
<li>如果您发现本文中存在用词错误,推到错误,或者程序存在bug等问题,请联系我进行核实与修正. 我非常重视文章质量.</li>
<li>如果您认为文章中的某些内容有侵权行为,请立刻联系我</li>
<li>按照这个git repo中的LICENSE使用CC0授权.</li>
</ul>
<blockquote>
<p>本文源自于我的研学报告.</p>
</blockquote>
<p>[TOC]</p>
<h2 id="记号与约定">0.记号与约定</h2>
<ul>
<li>文中出现的小写字母,如不做特殊说明,均为正整数.</li>
<li>默认出现在除数位置的数字不为0.</li>
<li>不区分质数与合数.</li>
<li>定义函数<span class="math inline">[p]</span>,其中<span class="math inline">p</span>为一命题,<span class="math inline">p</span>为真时<span class="math inline">[p]=1</span>否则<span class="math inline">[p]=0</span>.</li>
<li>定义函数<span class="math inline">\lfloor x \rfloor=\max\{y\in \mathbb{Z} \mid y\leq x\}</span>即向下取整函数.</li>
<li>定义函数<span class="math inline">\lceil x \rceil=\min\{y\in \mathbb Z \mid y\geq x\}</span>即向上取整函数.</li>
<li>默认<span class="math inline">\sum_{i=a}^bf(i)=\sum_{i=\lceil a \rceil}^{\lfloor b \rfloor}f(i)</span>出现在积分,求和上/下限的数分别向下/上取整.</li>
<li>当<span class="math inline">a&gt;b</span>时定义<span class="math inline">\sum_{i=a}^b f(i)=0</span></li>
<li>当<span class="math inline">a&gt;b</span>时定义<span class="math inline">\prod_{i=a}^b f(i)=1</span></li>
<li>定义<span class="math inline">\mathrm{prime}</span>为全体素数构成的集合,<span class="math inline">\mathrm{prime}_i</span>为第<span class="math inline">i</span>个素数(2为第1个).</li>
<li>定义<span class="math inline">mp(n)=\min\{p\in \mathrm{prime}: \, p\mid n\}</span>即最小质因子.</li>
</ul>
<h2 id="素数筛法">1.素数筛法</h2>
<h3 id="筛法简介">1.1 筛法简介</h3>
<p>Sieve of Eratosthenes是一个古老的算法,它基于这样一个思想<span class="math inline">n \in \mathrm{prime} \Rightarrow \forall p\in \mathrm{prime},p&lt; n \,\, p\nmid n</span>,这一命题的正确性比较显然,不做证明.Eratosthenes筛算法通过不断找出素数,筛出合数(排除含有因子<span class="math inline">p</span>且大于<span class="math inline">p</span>的数,即<span class="math inline">p</span>的倍数,这些数都是合数)从而得到不超过给定上限的所有素数.需要注意的是,如果对于每一个数字<span class="math inline">q</span>都尝试用<span class="math inline">p\in \mathrm{prime},p\leq \sqrt q</span>进行测试的话,算法复杂度会退化为<span class="math inline">O(n\sqrt n)</span>.</p>
<h3 id="筛法的实现与优化">1.2 筛法的实现与优化</h3>
<p>基于以上想法,我们不难给出这一算法的实现.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> vis[N],prime[N],cnt;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sieve(){</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    vis[<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;N;i++) <span class="cf">if</span>(!vis[i]){</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        prime[cnt++]=i;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">2</span>;i*j&lt;N;j++) vis[i*j]=<span class="dv">1</span>;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>这一实现已经非常高效了,但是仍有优化余地.考虑形如<span class="math inline">2p\,(p\in \mathrm{prime})</span>的数,已经被2排除为质数的可能后,还会被<span class="math inline">p</span>再次排除,我们使用<span class="math inline">p</span>进行筛除时应当避免被更小的质数筛除过的数,换言之,应该筛除<span class="math inline">mp(n)\geq p</span>的合数,这种<span class="math inline">n</span>满足<span class="math inline">p^2\leq n</span>,因为最小非1因子(即为最小质因子)不小于<span class="math inline">p</span>那么必须再乘一个不小于<span class="math inline">p</span>的数构成合数,显然是不小于<span class="math inline">p^2</span>的.</p>
<p>基于这一想法,我们对实现进行优化,得到如下的代码片段(需要说明的是,这一代码并不对于任意大的<span class="math inline">n</span>可用,可能出现乘法溢出等问题).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> vis[N],prime[N],cnt;</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sieve(){</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    vis[<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i*i&lt;N;i++) <span class="cf">if</span>(!vis[i])</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=i*i;j&lt;N;j+=i) vis[j]=<span class="dv">1</span>;</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;N;i++) <span class="cf">if</span>(!vis[i]) prime[cnt++]=i;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>然而即使加了这一优化,也无法做到每个合数只被筛除一次.不过我们知道一个数<span class="math inline">n</span>的不同质因子个数是远低于<span class="math inline">O(\log n)</span>量级的.算法复杂度并不会高于<span class="math inline">O(n\log n)</span>.</p>
<p>另外,这一算法的空间复杂度也过高,如求解<span class="math inline">10^{11}</span>内的质数,将会需要<code>100GB</code>的以上的空间,无法存储在内存中而需要进行磁盘的IO,cache也由于大步长访问难以命中,严重影响性能.针对空间问题,我们发现<code>prime</code>数组是无用的,可以省去;<code>vis</code>数组元素的取值仅为0,1,可以使用位图代替数组(如C++中的STL容器<code>bitset</code>,java中的<code>bitmap</code>等),大约空间使用降低到原来的<span class="math inline">\frac{1}{64\times 4}</span>.</p>
<h3 id="筛法的复杂度分析">1.3 筛法的复杂度分析</h3>
<p>空间复杂度分析略过,考虑算法的时间复杂度,主要花销在于遍历质数<span class="math inline">p</span>的倍数,在<span class="math inline">n</span>以内有<span class="math inline">\lfloor\frac{n}{p}\rfloor</span>,不难列出. <span class="math display">
\begin{aligned}
T(n)=\sum_{\begin{subarray}{l}p\in prime\\ p\leq n\end{subarray}}\lfloor \frac{n}{p}\rfloor
\leq n\sum_{\begin{subarray}{l}p\in prime\\ p\leq n\end{subarray}} \frac{1}{p}
&lt; n\sum_{i=1}^n\frac{1}{i}=nH(n)=O(n\log n)
\end{aligned}
</span> 不过把素数倒数和放大到调和级数太松了,通过查阅资料我们发现<span class="math inline">\sum_{\begin{subarray}{l}p\in \mathrm{prime}\\ p\leq n\end{subarray}}\frac{1}{p}</span>大约是<span class="math inline">O(\log\log n)</span>量级,故<span class="math inline">T(n)=O(n\log\log n)</span>这是一个足够好的上界.</p>
<p>另一方面,根据<span class="math inline">\pi(x)=O(\frac{n}{\log n})</span>,任取一<span class="math inline">n</span>以内的正整数,它为素数的概率是<span class="math inline">O(\frac{1}{\log n})</span>量级的.我们可以用期望来估算<span class="math inline">E(T(n))\leq n\sum_{i=1}^n \frac{1}{i\log n}=O(n\log\log n)</span>,得到了相同的结果.</p>
<h3 id="线性筛">1.4 线性筛</h3>
<p>线性筛即时间复杂度为线性的筛法,由欧拉提出,也称Euler’s sieve.这一算法可以看作是对于Sieve of Eratosthenes的优化也可以看作是由Eratosthenes筛不同的原理推导出的算法.这一算法的核心是“寻找最小质因子”.</p>
<p>遍历<span class="math inline">[2,3\ldots n]</span>,维护已经发现的素数列表和标记数组(被标记的不是素数).若遇到未被标记的数字,则发现了新质数,插入素数列表尾部.对于<span class="math inline">q</span>,用质数<span class="math inline">p_1=2,p_2=3\dots p_m</span>,其中<span class="math inline">p_m\mid q</span>标记<span class="math inline">qp_i</span>,且<span class="math inline">mp(qp_i)=p_i</span>.我们先基于这一描述给出实现.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> vis[N],prime[N],cnt;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sieve(){</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;N;i++){</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(!vis[i]) prime[cnt++]=i;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;N;j++){</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            vis[i*prime[j]]=<span class="dv">1</span>;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(i%prime[j]==<span class="dv">0</span>) <span class="cf">break</span>;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>可以证明,这一算法中,每个合数<span class="math inline">x</span>被<span class="math inline">mp(x)</span>筛除,且仅被筛除一次.下面给出证明.</p>
<p>考虑<span class="math inline">i=q</span>时,其中<span class="math inline">q</span>的标准分解形式为<span class="math inline">\prod_{i=1}^n (\mathrm{prime}_{a_i})^{b_i}</span>,被筛除的数为<span class="math inline">m=q\, \mathrm{prime}_j</span>其中<span class="math inline">j\leq a_1</span>.显然<span class="math inline">mp(m)\leq \mathrm{prime}_j</span></p>
<p>当<span class="math inline">j&lt; a_1</span>时<span class="math inline">\mathrm{prime}_j \nmid q</span>,若<span class="math inline">mp(m)=mp(q\, \mathrm{prime}_j)=\mathrm{prime}_k&lt; \mathrm{prime}_j</span>,可以得到<span class="math inline">\mathrm{prime}_j\, q=\mathrm{prime}_k\, q&#39;</span>其中<span class="math inline">q&#39; &gt; q</span>.将<span class="math inline">\mathrm{prime}_j\, q=\mathrm{prime}_k\, q&#39;</span>放到模<span class="math inline">\mathrm{prime}_k</span>意义下,有<span class="math inline">\mathrm{prime}_j\, q\equiv 0\pmod{prime}_k</span>,由于<span class="math inline">\gcd(\mathrm{prime}_j,\mathrm{prime}_k)=1</span>故<span class="math inline">\exists x&lt; \mathrm{prime}_k</span>使得<span class="math inline">x\, \mathrm{prime}_j\equiv 1\pmod {\mathrm{prime}_k}</span>,等式两边同时乘上<span class="math inline">x</span>,得到<span class="math inline">q\equiv 0\pmod {\mathrm{prime}_k}</span>从而有<span class="math inline">\mathrm{prime}_k \mid q</span>,但是<span class="math inline">\mathrm{prime}_k&lt; \mathrm{prime}_j&lt; \mathrm{prime}_{a_1}=mp(q)</span>我们发现<span class="math inline">q</span>的最小质因子并非<span class="math inline">\mathrm{prime}_{a_1}</span>产生了矛盾.</p>
<p>当<span class="math inline">j=a_1</span>时<span class="math inline">mp(q)=\mathrm{prime}_{a_1}=\mathrm{prime}_j</span>,考虑<span class="math inline">m=q\, \mathrm{prime}_j</span>的标准分解形式,<span class="math inline">m=\mathrm{prime}_{a_1}^{b_1+1}\prod_{i=2}^n (\mathrm{prime}_{a_i})^{b_i}</span>,显然有<span class="math inline">mp(m)=mp(q)=\mathrm{prime}_{a_1}=\mathrm{prime}_j</span></p>
<p>综上,每个数只会被最小质因子筛除,而筛除时是<span class="math inline">i\, \mathrm{prime}_j</span>这样一个配对形式,所以<span class="math inline">m=\frac{m}{mp(m)}\, mp(m)</span>被筛除时有<span class="math inline">\mathrm{prime}_j=mp(m)</span>进而<span class="math inline">i=\frac{m}{\mathrm{prime}_j}=\frac{m}{mp(m)}</span>是唯一确定的正整数.这说明了每个合数<span class="math inline">x</span>会被<span class="math inline">mp(x)</span>筛除,且只会被筛除一次.所以该算法的时间复杂度显然是线性的.</p>
<p>线性筛法看起来非常高效且充满了美感,但是我们仍要指出,这一算法的实现中涉及了取模运算,是非常耗时的操作,当数据规模较小(大约<span class="math inline">10^8</span>以内)时,这一实现表现不及Eratosthenes筛.并且由于算法过程的需要,我们必须保存素数列表空间消耗无法进一步优化.可以说再寻找素数这一工作上,euler’s sieve被前辈Eratosthenes筛吊打了.不过由于这一算法能够找到<span class="math inline">[1..n]</span>内所有数的最小质因子,它能够帮助我们完成一些特殊的积性函数求值任务,这是Eratosthenes筛难以做到的.</p>
<h2 id="数论函数求和方法">2.数论函数求和方法</h2>
<h3 id="一些定义">2.0 一些定义</h3>
<ul>
<li>数论函数,一个函数的定义域为正整数的子集,则称它为数论函数</li>
<li>数论积性函数,一个数论函数<span class="math inline">f(n)</span>若满足<span class="math inline">\forall a,b\, (a,b)=1 \Rightarrow f(ab)=f(a)f(b)</span></li>
<li>完全数论积性函数,一个数论函数<span class="math inline">f(n)</span>满足<span class="math inline">\forall a,b\quad f(ab)=f(a)f(b)</span></li>
<li>定义两个数论函数<span class="math inline">f(n),g(n)</span>的dirichlet卷积,为一个函数<span class="math inline">h(n)=\sum_{d\mid n} f(d)g(\frac{n}{d})</span></li>
<li>定义<span class="math inline">e(n)=[n=1]</span>称单位函数</li>
<li>定义<span class="math inline">1(n)=1</span>称常函数</li>
<li>定义<span class="math inline">id_k(n)=n^k</span></li>
<li>定义<span class="math inline">\sigma_k=id*1</span></li>
<li>定义<span class="math inline">\mu(n)</span>为满足<span class="math inline">1*\mu=e</span>的数论函数,可以证明,<span class="math inline">\mu</span>是唯一存在的,且为一个积性函数</li>
<li>定义<span class="math inline">\varphi=\mu* id</span>,(根据容斥原理)可以证明<span class="math inline">\varphi(n)=\sum_{i=1}^n[\gcd(i,n)=1]</span>,这是一个积性函数</li>
</ul>
<h3 id="线性筛法">2.1 线性筛法</h3>
<p>考虑如果在<span class="math inline">O(n)</span>时间内求出所有的<span class="math inline">\varphi(i)</span>,其中<span class="math inline">i\leq n</span>,我们先不加证明地给出以下性质.</p>
<p><span class="math display">
\begin{aligned}
&amp;\varphi(1)=1\\
&amp;\varphi(p^k)=p^{k-1}(p-1)=\quad p\in \mathrm{prime}\\
&amp;\varphi(n)=\varphi(\prod_{i=1}^m p_i^{c_i})=n\prod_{i=1}^m(1-\frac{1}{p_i})
\end{aligned}
</span></p>
<p>性质3告诉我们这样一个事实,若<span class="math inline">m=pq</span>,其中<span class="math inline">p\mid q</span>则<span class="math inline">\varphi(m)=\varphi(q) \, q</span>.考虑将它整合到线性筛法中.对于<span class="math inline">q</span>,筛除<span class="math inline">\mathrm{prime}_j\, q\quad \mathrm{prime}_j \mid q</span>时,有<span class="math inline">\varphi(\mathrm{prime}_j\, q)=\varphi(\mathrm{prime}_j)\varphi(q)=(p-1)\varphi(q)</span>.当筛除<span class="math inline">mp(q) q</span>时<span class="math inline">\varphi(mp(q)q)=mp(q)\varphi(q)</span>.得到了一个可行的算法.给出实现如下.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> vis[N],prime[N],cnt,phi[N];</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sieve(){</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    phi[<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;N;i++){</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(!vis[i]) phi[prime[cnt++]=i]=i-<span class="dv">1</span>;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;cnt&amp;&amp;<span class="dv">1</span><span class="bu">LL</span>*i*prime[j]&lt;N;j++){</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            vis[i*prime[j]]=<span class="dv">1</span>;</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(i%prime[j]==<span class="dv">0</span>){</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                phi[i*prime[j]]=phi[i]*prime[j];</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span>;</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            phi[i*prime[j]]=phi[i]*(prime[j]-<span class="dv">1</span>);</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>这一方法也可以推广到一些满足<span class="math inline">f(p^k)</span>为一个关于<span class="math inline">p,k</span>的低次(多项式次数deg相比于求解规模n可以忽略)多项式的情况,给出两个例子.</p>
<p><span class="math inline">O(n)</span>时间内求出所有求<span class="math inline">\sigma(n)=\sum_{d\mid n}d</span>和<span class="math inline">id_k(n)=n^k</span>,其中<span class="math inline">k=O(n)</span></p>
<p>对于<span class="math inline">id_k(n)</span>是一个完全积性函数筛除合数时简单相乘即可,并在<span class="math inline">n\in \mathrm{prime}</span>时使用快速幂技巧(一个经典的倍增算法)进行计算.发现时间复杂度<span class="math inline">T(n)\leq O(n)+\pi(n)O(\log k)=O(n)+O(\frac{n\log k}{\log n})=O(n)+O(n)=O(n)</span>仍然是线性的.</p>
<p>对于<span class="math inline">\sigma(n)</span>函数,显然是积性函数,且<span class="math inline">\sigma(p^k)=\sum_{i=0}^k p^i</span>.故<span class="math inline">\sigma(p^{k+1})=\sum_{i=0}^{k+1} p^i=p\sigma(p^{k+1})+1</span> 对于<span class="math inline">m=i\, \mathrm{prime}_j</span>,其中<span class="math inline">\mathrm{prime}_j \nmid i</span>的情况,<span class="math inline">\sigma(m)=\sigma(i)\sigma(\mathrm{prime}_j)=2\sigma(i)</span>.对于<span class="math inline">m=i\, mp(i)</span>的情况,设<span class="math inline">i=mp^a(i)\, q</span>,其中<span class="math inline">a=\max\{b \mid mp^b(i)\mid i\}</span>即标准分解形式中最小质因子的指数,显然<span class="math inline">\gcd(mp(i),q)=1</span>.故<span class="math inline">\sigma(m)=\sigma(i\, mp^{a+1}(i))=\sigma(mp^{a+1}(i)\, q)=\sigma(q)\sigma(mp^{a+1}(i))=\sigma(q)[mp(i)\, \sigma(mp^a(i))+1]</span>筛法求素数的过程中,维护<span class="math inline">\sigma(mp^k(i))</span>其中<span class="math inline">k=\max\{a\mid mp^a(i) \mid i\}</span>即可在解决问题.</p>
<p>更进一步地,对于给定的两个可以线性求解的积性函数<span class="math inline">f(n),g(n)</span>,我们可以线性求解<span class="math inline">h(n)=(f*g)(n)</span>.</p>
<h3 id="整除分块">2.2 整除分块</h3>
<p>这是一个用于求<span class="math inline">\sum_{i=1}^n \sigma_0(i)=\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor</span>的技巧,可以在<span class="math inline">O(\sqrt n)</span>时间内完成求解. 对于一个给定的<span class="math inline">n</span>,<span class="math inline">f_n(d)=\lfloor\frac{n}{d}\rfloor</span>显然关于<span class="math inline">d</span>单调不增,最大为<span class="math inline">n</span>,最小为<span class="math inline">1</span>似乎有<span class="math inline">n</span>种可能取值.不过一个好消息是<span class="math inline">d&gt;\frac{n}{2}\Rightarrow f_n(d)&lt; \frac{n}{\frac{n}{2}}=2 \Rightarrow f_n(d)=1</span>这说明有一半以上的<span class="math inline">f_n(d)</span>是相同的.更进一步的,<span class="math inline">f_n(d)=\lfloor\frac{n}{d}\rfloor</span>的可能取值是<span class="math inline">O(\sqrt n)</span>种.我们下面给出证明.</p>
<p>对于<span class="math inline">d\leq \sqrt n</span>,这种<span class="math inline">d</span>是<span class="math inline">O(\sqrt n)</span>的,即使每一个<span class="math inline">f_n(d)</span>都不同,取值也是<span class="math inline">O(\sqrt n)</span>的.对于<span class="math inline">d&gt;\sqrt n</span>,<span class="math inline">\lfloor\frac{n}{d}\rfloor \leq \frac{n}{\sqrt n}\leq \sqrt n</span>,于是可能的取值仍然是<span class="math inline">O(\sqrt n)</span>的.综合两部分,<span class="math inline">\lfloor\frac{n}{d}\rfloor</span>对于给定的n,只有<span class="math inline">O(\sqrt n)</span>种取值.</p>
<p>这一证明的指导思想是<span class="math inline">ab\leq n\Rightarrow \min(a,b)\leq \sqrt n</span>.值得一提的是:这一上界是非常紧的,难以得到更紧且更优美的上界.</p>
<p>由于<span class="math inline">\lfloor\frac{n}{d}\rfloor</span>的单调性,考虑使得<span class="math inline">\lfloor\frac{n}{d}\rfloor \neq \lfloor\frac{n}{d-1}\rfloor</span>的<span class="math inline">d</span>,记为<span class="math inline">d_1,d_2\dots d_m</span>,它们会将区间<span class="math inline">[1,n]</span>分成<span class="math inline">O(\sqrt n)</span>个区间.如果我们能对于一个确定的<span class="math inline">d</span>,<span class="math inline">O(1)</span>时间内求出<span class="math inline">q=\max\{p\mid \lfloor\frac{n}{p}\rfloor=\lfloor\frac{n}{d}\rfloor\}</span>即可在<span class="math inline">O(\sqrt n)</span>时间内计算<span class="math inline">\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor</span>.通过手动找规律猜想结合证明,我们得到<span class="math inline">\max\{p\mid \lfloor \frac{n}{p}\rfloor=d\}=\lfloor\frac{n}{d}\rfloor</span>.我们跳过对此的性质的严谨证明.下面直接给出求解<span class="math inline">\sum_{i=1}^n \lfloor\frac{n}{i}\rfloor</span>的算法的实现.</p>
<p>需要注意的是,由于直接使用c++ int类型(32bit有符号整数),这一实现在<span class="math inline">n</span>较大时会发生整数溢出.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> solve(<span class="dt">int</span> n){</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> res=<span class="dv">0</span>,l=<span class="dv">1</span>,r=<span class="dv">0</span>,q=<span class="dv">0</span>;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(l&lt;=n){</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        q=n/l; r=n/q;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        res=res+q*(r-l+<span class="dv">1</span>);</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        l=r+<span class="dv">1</span>;</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res;</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>有了这一算法的启发,求解形如<span class="math inline">\sum_{i=1}^n f(i)\lfloor\frac{n}{i}\rfloor</span>和<span class="math inline">\sum_{i=1}^n f(\lfloor\frac{n}{i}\rfloor) p(i)</span>的问题时,也可以根据<span class="math inline">\lfloor\frac{n}{d}\rfloor</span>的结果对于<span class="math inline">d</span>将答案切分成几个不相交的块进行计算.这一技巧被国内算法竞赛选手称为“整除分块”.</p>
<h3 id="dirichlet卷积">2.3 dirichlet卷积</h3>
<p>定义两个数论函数<span class="math inline">f(n),g(n)</span>的dirichlet卷积卷积为一个数论函数<span class="math inline">h(n)</span>,满足<span class="math inline">h(n)=\sum_{d\mid n} f(d)g(\frac{n}{d})</span>.记为<span class="math inline">h=f*g</span>.下面我们不加证明地给出一些dirichlet卷积的性质.</p>
<ul>
<li>交换律:<span class="math inline">f*g=g*f</span></li>
<li>结合律:<span class="math inline">(f*g)*h=f*(g*h)</span></li>
<li>对加法的分配律:<span class="math inline">f*(g+h)=f*g+f*h</span></li>
<li>存在单位元:<span class="math inline">e(n)=[n=1]</span></li>
<li>两个积性函数的卷积仍然是积性函数</li>
</ul>
<p>dirichlet卷积是一个非常有用的工具,下面举一个例子来说明.</p>
<p>以低于<span class="math inline">O(n)</span>的时间求<span class="math inline">S(n)=\sum_{i=1}^n \mu(i)</span>.根据<span class="math inline">\mu</span>的定义<span class="math inline">\mu*1=e</span>.我们下面尝试使用卷积构造<span class="math inline">S(n)</span>的递推式.</p>
<p><span class="math display">
\begin{aligned}
&amp;1=\sum_{i=1}^n e(i)=\sum_{i=1}^n(\mu*1)(i)=
\sum_{i=1}^n\sum_{d\mid i}1(d)\mu(\frac{i}{d})\\
&amp;\sum_{i=1}^n\sum_{d\mid i}\mu(\frac{i}{d})=\sum_{i=1}^n\sum_{d=1}^n[d\mid i]\mu(\frac{i}{d})
=\sum_{d=1}^n\sum_{i=1}^n[d\mid i]\mu(\frac{i}{d})\\
&amp;=\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(\frac{id}{d})
=\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(i)=
\sum_{d=1}^nS({\lfloor\frac{n}{d}\rfloor})\\
&amp;1=\sum_{d=1}^nS({\lfloor\frac{n}{d}\rfloor})
=S(n)+\sum_{d=2}^nS({\lfloor\frac{n}{d}\rfloor})\\
&amp;S(n)=1-\sum_{d=2}^nS({\lfloor\frac{n}{d}\rfloor})
\end{aligned}
</span></p>
<p><span class="math display">
\begin{aligned}
&amp;1=\sum_{i=1}^n e(i)=\sum_{i=1}^n(\mu*1)(i)=
\sum_{i=1}^n\sum_{d\mid i}1(d)\mu(\frac{i}{d})\\
&amp;\sum_{i=1}^n\sum_{d\mid i}\mu(\frac{i}{d})=\sum_{i=1}^n\sum_{d=1}^n[d\mid i]\mu(\frac{i}{d})
=\sum_{d=1}^n\sum_{i=1}^n[d\mid i]\mu(\frac{i}{d})\\
&amp;=\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(\frac{id}{d})
=\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(i)=
\sum_{d=1}^nS({\lfloor\frac{n}{d}\rfloor})\\
&amp;1=\sum_{d=1}^nS({\lfloor\frac{n}{d}\rfloor})
=S(n)+\sum_{d=2}^nS({\lfloor\frac{n}{d}\rfloor})\\
&amp;S(n)=1-\sum_{d=2}^nS({\lfloor\frac{n}{d}\rfloor})
\end{aligned}
</span></p>
<p>利用这个递推式,进行记忆化搜索,就可以在低于线性的时间内解决这一问题了.这里给出实现.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> Int;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> Int mod=<span class="dv">998244353</span><span class="bu">LL</span>;</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>unordered_map&lt;Int,Int&gt; tbl;</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>Int sum(Int n){</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(n&lt;<span class="dv">1</span>) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(tbl.count(n)) <span class="cf">return</span> tbl[n];</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    Int ret=<span class="dv">1</span>,l=<span class="dv">2</span>,r=<span class="dv">0</span>,q=<span class="dv">0</span>;</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(l&lt;=n){</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        q=n/l; r=n/q;</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        ret=ret-sum(q)*(r-l+<span class="dv">1</span>)%mod;</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        ret=(ret%mod+mod)%mod;</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        l=r+<span class="dv">1</span>;</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tbl[n]=ret;</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>下面我们来分析以下算法的复杂度.这里先给出一个关于向下取整函数的性质.<span class="math inline">\lfloor\frac{a}{bc}\rfloor=\lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c}\rfloor</span>利用带余除法很好证明,这里跳过.这一性质告诉我们如果利用这一递推式进行计算,涉及到的不同<span class="math inline">S(m)</span>是和<span class="math inline">\lfloor\frac{n}{a}\rfloor</span>的取值种类一样为<span class="math inline">O(\sqrt n)</span>个.给出这一结论的证明.</p>
<p>首先<span class="math inline">n=\lfloor\frac{n}{1}\rfloor</span>,<span class="math inline">S(n)=1-\sum_{d=2}^nS({\lfloor\frac{n}{d}\rfloor})</span>,只涉及到形如<span class="math inline">S(\lfloor\frac{n}{a}\rfloor)</span>的项.</p>
<p>对于其中的每个<span class="math inline">S(\lfloor\frac{n}{d}\rfloor)</span>再次展开,<span class="math inline">S(\lfloor\frac{n}{d}\rfloor)=1-\sum_{p=2}^{\lfloor\frac{n}{d}\rfloor}S(\lfloor\frac{\lfloor\frac{n}{d}\rfloor}{p}\rfloor)=1-\sum_{p=2}^{\lfloor\frac{n}{d}\rfloor}S(\lfloor\frac{n}{dp}\rfloor)</span>.仍然是形如<span class="math inline">S(\lfloor\frac{n}{a}\rfloor)</span>的项.继续展开显然只会涉及有限项,同理可以说明,所以结论正确.</p>
<p>接下来可以估计时间复杂度了,类似于证明<span class="math inline">\lfloor\frac{n}{d}\rfloor</span>的取值只有<span class="math inline">O(\sqrt n)</span>种的过程,我们考虑按照<span class="math inline">d</span>和<span class="math inline">\sqrt n</span>的大小关系分类进行计算.由于采用了记忆化搜索,我们直接估计转移的次数(进入sum函数的次数)即可.具体地,对于<span class="math inline">S(n)</span>,需要先求出<span class="math inline">S(\lfloor\frac{n}{i}\rfloor)\quad i\leq n</span>,共<span class="math inline">O(\sqrt n)</span>个转移.下面给出复杂度计算.</p>
<p><span class="math display">
\begin{aligned}
T(n)
&amp;= \sum_{i=1}^{\sqrt n} \sqrt i+\sum_{i=1}^{\sqrt n}\sqrt{\frac{n}{i}}\\
&amp;\sim \int_1^{\sqrt n} \sqrt{x}dx + \int_1^{\sqrt n} \sqrt{\frac{n}{x}}dx\\
&amp;= \frac{2}{3}x^{\frac{3}{2}} {\vert}_1^{\sqrt n}+(2\sqrt{n}x^{\frac{1}{2}}) {\vert}_{1}^{\sqrt n}\\
&amp;= O(n^\frac34)-O(1)+O(n^\frac34)-O(1)=O(n^\frac34)
\end{aligned}
</span></p>
<p>显然积分估计的结果和求和的结果是远低于<span class="math inline">O(n^\frac34)</span>的,所以<span class="math inline">T(n)=O(n^\frac34)</span>,这个上界是较紧的.</p>
<p>回顾推导过程,我们并没有利用<span class="math inline">\mu(n),1(n)</span>各自的特殊性质,只是对<span class="math inline">e(n)=(\mu*1)(n)</span>进行求和便得到了递推式,所以这一方法可以轻松地推广到任意两个数论函数<span class="math inline">f(n),g(n)</span>上.令<span class="math inline">S(n)=\sum_{i=1}^ng(i)</span>,给出<span class="math inline">S(n)</span>的递推式.</p>
<p><span class="math display">
\begin{aligned}
&amp;\sum_{i=1}^n(f*g)(i)=\sum_{i=1}^n\sum_{d\mid i}f(d)g(\frac{i}{d})
=\sum_{d=1}^nf(d)\sum/t_{i=1}^{\lfloor\frac{n}{d}\rfloor}g(i)
=\sum_{d=1}^nf(d)S(\lfloor\frac{n}{d}\rfloor)\\
&amp;f(1)S(n)=\sum_{i=1}^n(f*g)(i)-\sum_{d=2}^n f(d)S(\lfloor\frac{n}{d}\rfloor)
\end{aligned}
</span></p>
<p>套用刚刚的记忆化搜索,若求解<span class="math inline">\sum_{i=1}^n (f*g)(i),\sum_{i=1}^nf(i)</span>在全部<span class="math inline">\lfloor\frac{n}{d}\rfloor</span>处的取值的总复杂度不超过<span class="math inline">O(n^\frac34)</span>则可以<span class="math inline">O(n^\frac34)</span>内求解<span class="math inline">S(n)</span>.此外若可以<span class="math inline">O(n)</span>时间内求出<span class="math inline">S(1),S(2)\dots S(n)</span>.还可以对<span class="math inline">S(n)</span>进行预处理,从而把复杂度从<span class="math inline">O(n^\frac34)</span>优化到<span class="math inline">O(n^\frac23)</span>,具体地.则使用<span class="math inline">O(n^\frac23)</span>时间预处理<span class="math inline">S(1),S(2)\dots S(\lfloor n^\frac23\rfloor)</span>,后再进行记忆化搜索即可.利用积分估计复杂度.</p>
<p><span class="math display">
T(n)=O(n^\frac23)+\int_{1}^{n^\frac13}\sqrt{\frac{n}{x}}dx=
O(n^\frac23)+O(n^{\frac12+\frac{1}{2}\times\frac13})=
O(n^\frac23)
</span></p>
<p>这个利用dirichlet卷积构造递推式进行记忆化搜索的技巧,在国内算法竞赛圈内被称为“杜教筛”,由杜瑜皓引入国内.</p>
<h3 id="莫比乌斯反演">2.4 莫比乌斯反演</h3>
<p>莫比乌斯反演是这样一个技巧<span class="math inline">f(n)=\sum_{d\mid n}\mu(\frac{n}{d})g(d)</span>,其中<span class="math inline">g(n)=\sum_{d|n}f(d)</span>.</p>
<p>上述等式很容易借助dirichlet卷积证明,<span class="math inline">f=(\mu*1)*f=\mu*(1*f)</span>.也可以根据<span class="math inline">\mu(\prod_{i=1}^n \mathrm{prime}_{a_i})=(-1)^n</span>和<span class="math inline">\sum_{i=1}^n(-1)^{i}\binom{n}{i}=[n=1]</span>进行证明,或者基于多重集容斥原理证明,由于莫比乌斯反演和本文主题关联不大,故略去对它们的详细介绍.</p>
<p>这里给出一个使用莫比乌斯反演和卷积的例题.求<span class="math inline">\sum_{i_1=1}^{m}\sum_{i_2=1}^{m} \dots \sum_{i_n=1}^{m}\gcd(i_1,i_2,i_3, \dots i_n)</span>其中<span class="math inline">m=\Theta(n)</span>即<span class="math inline">n,m</span>同阶,<span class="math inline">\gcd</span>为表示最大公约数,这一题目来自于陈卓裕,可以在<a href="https://loj.ac/problem/6491">LOJ 6491</a>提交.</p>
<p>由于最大公约数函数并没有很好的性质,我们考虑转求和为计数.考虑<span class="math inline">gcd</span>的每一种取值<span class="math inline">d</span>会出现多少次,即有多少组<span class="math inline">(i_1,i_2\dots i_n)</span>满足<span class="math inline">(i_1,i_2\dots i_n)=d</span>.并将<span class="math inline">\sum_{d\mid n}\mu(d)=e(n)</span>带入.给出完整推导过程.</p>
<p><span class="math display">
\begin{aligned}
&amp;\sum_{i_1=1}^{m}\sum_{i_2=1}^{m} \dots \sum_{i_n=1}^{m}\gcd(i_1,i_2,i_3, \dots i_n)=
\sum_{d=1}^m d
    \sum_{i_1=1}^m \sum_{i_2=1}^{m} \dots \sum_{i_n=1}^{m}
    [\gcd(i_1,i_2,i_3, \dots i_n)=d]\\
&amp;=\sum_{d=1}^m d
    \sum_{i_1=1}^{\lfloor \frac{m}{d} \rfloor} 
    \sum_{i_2=1}^{\lfloor \frac{m}{d} \rfloor}
    \dots
    \sum_{i_n=1}^{\lfloor \frac{m}{d} \rfloor}
        [\gcd(i_1,i_2,i_3, \dots i_n)=1]
=\sum_{d=1}^m d f(n,\lfloor\frac{m}{d}\rfloor)\\
&amp;f(n,m)=
    \sum_{i_1=1}^m
    \sum_{i_2=1}^m
    \dots
    \sum_{i_n=1}^m
        [\gcd(i_1,i_2\dots i_n)=1]
=   
    \sum_{i_1=1}^m
    \sum_{i_2=1}^m
    \dots
    \sum_{i_n=1}^m
        \sum_{d \mid \gcd(i_1,i_2\dots i_n)} \mu(d)\\
&amp;=\sum_{d=1}^m \mu(d)
    \sum_{i_1=1}^m
    \sum_{i_2=1}^m
    \dots
    \sum_{i_n=1}^m
    [d|i_1][d|i_2]\dots[d|i_n]\\
&amp;=\sum_{d=1}^m \mu(d)
    {(\lfloor\frac{m}{d}\rfloor)}^{n}\\
&amp;\sum_{i_1=1}^{m}\sum_{i_2=1}^{m} \dots \sum_{i_n=1}^{m}\gcd(i_1,i_2,i_3, \dots i_n)
=\sum_{d=1}^m d f(n,\lfloor\frac{m}{d}\rfloor)\\
&amp;=\sum_{d=1}^m d\sum_{p=1}^{\lfloor\frac{m}{d}\rfloor}
    \mu(p){(\lfloor\frac{m}{pd}\rfloor)}^{n}
=\sum_{T=1}^m \sum_{d|T}d\mu(\frac{T}{d})(\lfloor\frac{m}{T}\rfloor)^n
=\sum_{T=1}^m (\lfloor\frac{m}{T}\rfloor)^n\varphi(T)
\end{aligned}
</span></p>
<p>套用整除分块和杜教筛,再预处理<span class="math inline">\varphi(n)</span>的前<span class="math inline">m^\frac{2}{3}</span>项,即可<span class="math inline">O(n^\frac23)</span>解决问题.值得注意的是,这里需要求解<span class="math inline">S(n)=\sum_{i=1}^n\varphi(i)</span>在<span class="math inline">\lfloor\frac{m}{d}\rfloor</span>其中<span class="math inline">d=1,2,3\dots m</span>,共<span class="math inline">O(\sqrt m)</span>处的取值,而不仅仅是<span class="math inline">S(m)</span>,这里复杂度是如何保证不退化的呢?</p>
<p>考虑记忆化搜索的过程,我们实际上遍历了<span class="math inline">S(\lfloor\frac{m}{d}\rfloor)</span>其中<span class="math inline">d=1,2,3\dots m</span>,并且将它们都一起求出了,所以杜教筛这一技巧实际上是在<span class="math inline">O(n^\frac23)</span>内求解了<span class="math inline">S(n)</span>,在所有形如<span class="math inline">S(\lfloor\frac{n}{d}\rfloor)</span>共<span class="math inline">O(\sqrt n)</span>处的取值,因此总求解复杂度仍然是<span class="math inline">O(n^\frac23)</span>的.</p>
<h3 id="min_25筛">2.5 min_25筛</h3>
<h4 id="min_25筛简介">2.5.1 min_25筛简介</h4>
<p>这是一个用于求解数论积性函数前缀和的方法,其复杂度并不优美,但实现简单且实际运行效率极高.它由日本算法竞赛选手<code>min_25</code>发明,2016年左右被引入中国,国内算法竞赛选手称其为<code>min_25</code>筛.</p>
<h4 id="min_25筛适用条件">2.5.2 min_25筛适用条件</h4>
<p>考虑求<span class="math inline">S(n)=\sum_{i=1}^nf(i)</span>.其中<span class="math inline">f(n)</span>是满足如下条件的数论函数.</p>
<ul>
<li><span class="math inline">f(p),p\in \mathrm{prime}</span>,即在质数处的取值,是一个关于<span class="math inline">p</span>的低次多项式<span class="math inline">G(p)</span>(满足<span class="math inline">\deg(G(p))n=O(n)</span>时可以认为多项式<span class="math inline">G(p)</span>是低次的)</li>
<li><span class="math inline">f(p^c),p\in \mathrm{prime}</span>,即在质数的幂处的取值,是可以<span class="math inline">O(1)</span>求出,或者可以由<span class="math inline">f(p^{c-1})</span>在<span class="math inline">O(1)</span>内推出</li>
<li><span class="math inline">f(n)</span>是积性函数(更一般的<span class="math inline">n</span>的不同质因子对于<span class="math inline">f(n)</span>的贡献独立即可,即满足<span class="math inline">\gcd(a,b)=1\Rightarrow f(ab)=g(f(a),f(b))</span>,其中<span class="math inline">g(a,b)</span>是是一个可以在<span class="math inline">a,b</span>给定的情况下快速求值的函数)</li>
</ul>
<h4 id="min_25筛推导">2.5.3 min_25筛推导</h4>
<p>首先考虑枚举<span class="math inline">i</span>的最小质因子<span class="math inline">mp(i)=p</span>以及它在<span class="math inline">i</span>的标准分解形式种的指数<span class="math inline">c=\max\{b\geq 0\mid \, p^b\mid i\}</span>,将<span class="math inline">p^c</span>从<span class="math inline">i</span>种提取出来,显然剩余部分为<span class="math inline">1</span>或者满足<span class="math inline">mp(\frac{i}{p^c})&gt;p</span>.</p>
<p><span class="math display">
\begin{aligned}
\sum_{i=1}^nf(i)=
f(1)+\sum_{\begin{subarray}{l} {2\leq p^c \leq n} \\ {p \in \mathrm{prime}}\end{subarray}}
f(p^c)(1+
\sum_{
    \begin{subarray}{l}
        2\leq x\leq \lfloor\frac{n}{p^c}\rfloor\\
        mp(x) &gt; p
    \end{subarray}
}f(x))  
\end{aligned}
</span></p>
<p>若<span class="math inline">x</span>为合数则有.<span class="math inline">mp(x)\leq \sqrt x \leq \sqrt n</span>;若<span class="math inline">mp(x)&gt; \sqrt x</span>则说明<span class="math inline">x</span>为质数.于是我们按照<span class="math inline">p</span>和<span class="math inline">\sqrt n</span>的大小关系分类.</p>
<p><span class="math display">
f(1)
+\sum_{
    \begin{subarray}{l}
        2\leq p^c\leq \sqrt n\\
        p\in \mathrm{prime}
    \end{subarray}
} f(p^c)
    \left(
        1+\sum_{
            \begin{subarray}{l}
                mp(x)&gt; p\\
                2\leq x\leq \lfloor\frac{n}{p^c}\rfloor
            \end{subarray}
        } f(x)
    \right)
+\sum_{\begin{subarray}{l} p\in \mathrm{prime}\\ \sqrt n&lt; p\leq n\end{subarray}}f(p)
</span></p>
<p>为了进一步化简进行计算,我们引入辅助函数<span class="math inline">g_{n,m}</span>与<span class="math inline">h_n</span>定义如下:</p>
<ul>
<li><span class="math inline">g_{n,m}</span>为<span class="math inline">n</span>以内,最小质因子大于<span class="math inline">m</span>的贡献.<span class="math inline">g_{n,m}=\sum_{mp(x)&gt; m\land 2\leq x \leq n}f(x)</span></li>
<li><span class="math inline">h_n</span>为<span class="math inline">n</span>以内素数对于<span class="math inline">S(n)</span>的贡献.<span class="math inline">h_n=\sum_{p\in \mathrm{prime}\land 2 &lt; p \leq n}f(p)</span></li>
</ul>
<p>根据<span class="math inline">g</span>的定义由<span class="math inline">\sum_{i=1}^n f(i)=S(n)=g_{n,1}+f(1)</span>尝试寻找<span class="math inline">g</span>的递推式.</p>
<p><span class="math display">
\begin{aligned}
&amp;g_{n,m}=\sum_{\begin{subarray}{l} mp(x)&gt; m\land 2\leq x\leq n\end{subarray}}f(x)\\
&amp;=\sum_{\begin{subarray}{l} p^c\leq n\\ p\in \mathrm{prime}\\ m&lt; p \leq \sqrt n \end{subarray}}
f(p^c)(1+\sum_{\begin{subarray}{l} mp(x)&gt; p\\2\leq x \leq \lfloor\frac{n}{p^c}\rfloor\end{subarray}}f(x))+\sum_{\begin{subarray}{l} p\in \mathrm{prime}\\ \sqrt n &lt; p \leq n\end{subarray}}f(p)\\
&amp;=\sum_{\begin{subarray}{l} p^c \leq n\\p\in \mathrm{prime}\\ m&lt; p \leq \sqrt n\end{subarray}}f(p^c)(1+g_{\lfloor\frac{n}{p^c}\rfloor,p})+h_n-h_{\sqrt n}
\end{aligned}
</span></p>
<p>我们发现如果要根据这一递推式求解<span class="math inline">g</span>,那么需要求出两类<span class="math inline">h_n</span>.</p>
<p>一类是<span class="math inline">h_{\sqrt x}</span>,显然<span class="math inline">\sqrt x\leq \sqrt n</span>可以<span class="math inline">O(\sqrt n)</span>预处理(之前的线性筛部分已经分析过若对于特定质数<span class="math inline">p</span>,可以<span class="math inline">O(\log n)</span>求出<span class="math inline">f(p)</span>,且<span class="math inline">f(n)</span>为积性函数,则可以<span class="math inline">O(n)</span>时间求出<span class="math inline">f(i) \, i=1,2,3,\dots n</span>).</p>
<p>另一类是形如<span class="math inline">h_{\lfloor\frac{n}{d}\rfloor}</span>的<span class="math inline">h_m</span>,这是由于<span class="math inline">\lfloor\frac{\lfloor\frac{n}{i}\rfloor}{j}\rfloor=\lfloor\frac{n}{ij}\rfloor</span>,考虑<span class="math inline">g_{n,m}</span>的递推式,不难发现求解<span class="math inline">g_{n,1}</span>只会涉及形如<span class="math inline">h_{\lfloor\frac{n}{d}\rfloor}</span>的,<span class="math inline">h_m</span>,只有<span class="math inline">O(\sqrt n)</span>种.</p>
<p>如果能快速求出计算<span class="math inline">g_{n,1}</span>种需要的所有<span class="math inline">h_m</span>,那么利用递推式就能轻松求出<span class="math inline">g</span>了.值得一提的是,递归求解<span class="math inline">g</span>并不需要记忆化结果,即使使用了记忆化搜索也不能优化复杂度,将在后续对<code>min_25</code>筛复杂度分析的部分说明.</p>
<p>现在来考虑求解<span class="math inline">h_n</span></p>
<p><span class="math display">
\begin{aligned}
h_n=\sum_{\begin{subarray}{l}p\in \mathrm{prime}\\ 2&lt; p \leq n\end{subarray}}f(p)
\end{aligned}
</span></p>
<p><span class="math inline">f(p)=G(p)</span>是一个低次多项式.<span class="math inline">f(p)=\sum_{i=0}^k c_ip^i</span>.带入<span class="math inline">h_n</span>的定义中,整理得到如下式子.</p>
<p><span class="math display">
\begin{aligned}
h_n=\sum_{\begin{subarray}{l}p\in \mathrm{prime}\\ 2&lt; p \leq n\end{subarray}}f(p)=
\sum_{\begin{subarray}{l}p\in \mathrm{prime}\\ 2&lt; p \leq n\end{subarray}}\sum_{i=0}^k c_i p^i=
\sum_{i=0}^k c_i\sum_{\begin{subarray}{l}p\in \mathrm{prime}\\ 2&lt; p \leq n\end{subarray}} p^i
\end{aligned}
</span> 观察结果,求<span class="math inline">h_n</span>被转为求素数<span class="math inline">k</span>次幂和.</p>
<p>定义辅助函数<span class="math inline">L_{n,m}</span>.</p>
<p><span class="math display">
L_{n,m}=\sum_{i=2}^n[(i\in \mathrm{prime})\, or\, (mp(i)&gt; \mathrm{prime}_m)]\  i^k
</span></p>
<p>即<span class="math inline">[1,n]</span>内的质数<span class="math inline">k</span>次幂与,满足<span class="math inline">mp(x)&gt;\mathrm{prime}_m</span>的数的k次幂和.或者换一个角度,<span class="math inline">L_{n,m}</span>是Eratosthenes筛第m轮筛后没有被筛除的数的<span class="math inline">k</span>次幂和.根据这个定义,有<span class="math inline">L_{n,\sqrt n}=\sum_{p\in \mathrm{prime},p\leq n} p^k</span>,因为任意一个<span class="math inline">n</span>以内的合数<span class="math inline">x</span>满足<span class="math inline">mp(x)\leq \sqrt n</span>.</p>
<p>考虑一个不断用素数筛除不满足约束的数的过程,考虑最小质因子为<span class="math inline">p_m</span>的数<span class="math inline">x=p_m\cdot y\leq n \Rightarrow y\leq \lfloor \frac{n}{p_m} \rfloor</span>,可以从<span class="math inline">L_{n,m-1}</span>中扣除<span class="math inline">p_m^k \, L_{\lfloor\frac{n}{p_m}\rfloor,m-1}</span>从而得到<span class="math inline">L_{n,m}</span>.但是<span class="math inline">p_m^k \, L_{\lfloor\frac{n}{p_m}\rfloor,m-1}</span>包含了形如<span class="math inline">x=q\cdot p_m,x\leq n</span>其中<span class="math inline">mp(q) &lt; p_m</span>的<span class="math inline">x</span>的贡献,它们应该在之前被更小的质数排除.</p>
<p>再考虑这种<span class="math inline">q</span>,必定是<span class="math inline">q=p_i,p_i&lt; p_m,p_i\in \mathrm{prime}</span>的,不然<span class="math inline">q</span>已经被筛掉了.所以补上一个<span class="math inline">pre_{m-1}</span>,这样找到的<span class="math inline">x=p_m\cdot y</span>就是我们本轮需要筛除的数了.</p>
<p>我们发现这样做扣除且仅扣除了所有满足<span class="math inline">x\not\in \mathrm{prime},x\leq n,mp(x)=p_m</span>的<span class="math inline">x</span>对于<span class="math inline">L_{n,m-1}</span>的贡献.得到了<span class="math inline">L_{n,m}</span>.形式化的说.</p>
<p><span class="math display">
\begin{aligned}
&amp;L_{n,m}=L_{n,m-1}-p_m^k(L_{\lfloor\frac{n}{p_m}\rfloor,m-1}-pre_{m-1})\\
&amp;pre_m=\sum_{i=1}^m {(\mathrm{prime}_i)}^k
\end{aligned}
</span></p>
<p>如果<span class="math inline">p_m^2&gt;n</span>了那么不需要计算了,直接令<span class="math inline">L_{n,m}=L_{n,m-1}</span>理由如下.</p>
<p>设最小质因子不小于<span class="math inline">p_j</span>的最小合数为<span class="math inline">x</span>,显然<span class="math inline">mp(x)\geq p_j</span>故<span class="math inline">x\geq p_j^2&gt;</span> n,这说明<span class="math inline">L_{n,m-1}</span>中不包含这种<span class="math inline">mp(x)=p_j\ ,x\not \in \mathrm{prime}</span>的<span class="math inline">x</span>的贡献,即<span class="math inline">L_{n,,m}=L_{n,m-1}</span>.另外<span class="math inline">L_{n,1}=\sum_{i=2}^n i^k</span></p>
<p>于是,结合利用递推式计算<span class="math inline">g_{n,1}</span>,类筛法计算<span class="math inline">L_{n,m}</span>,得到了这样一个完整的用于求解<span class="math inline">S(n)</span>的算法.</p>
<ol type="1">
<li>预处理<span class="math inline">\sqrt n</span>以内的质数与<span class="math inline">pre_x=\sum_{i=1}^x (\mathrm{prime}_i)^k</span>.</li>
<li>找到<span class="math inline">g_{n,1}</span>需要的<span class="math inline">h_m</span>.共<span class="math inline">O(\sqrt n)</span>项,初始令<span class="math inline">h&#39;(m)=L_{m,1}=\sum_{i=2}^mi^k</span></li>
<li>从小到达枚举不超过<span class="math inline">\sqrt n</span>的质数<span class="math inline">\mathrm{prime}_j</span>,并从小到大枚举<span class="math inline">d</span>对应的<span class="math inline">\lfloor\frac{n}{d}\rfloor</span>的取值<span class="math inline">m</span>,从<span class="math inline">m=\lfloor\frac{n}{1}\rfloor=n</span>开始到<span class="math inline">\mathrm{prime}_j^2&gt; m=\lfloor\frac{n}{d}\rfloor</span>为止,从<span class="math inline">h&#39;_m</span>中扣除<span class="math inline">\mathrm{prime}_j^k(h&#39;_{\lfloor\frac{m}{\mathrm{prime}_j}\rfloor}-pre_{m-1})</span>使得<span class="math inline">h&#39;_m=L_{m,j}</span></li>
<li>最后<span class="math inline">\sum_{i=1}^nf(i)=g_{n,1}+f(1)</span>.根据<span class="math inline">g</span>的递推式进入递归求解,这里不需要记忆化.</li>
</ol>
<h4 id="min_25筛复杂度分析">2.5.4 min_25筛复杂度分析</h4>
<p>首先是类筛法求<span class="math inline">h</span>,这一部分分析较为容易但是涉及到了对数积分,我们利用Wolfram Alpha做近似求解.</p>
<p>第一部分是求解<span class="math inline">h_n</span>.<br />
考虑一个需要求解的<span class="math inline">h_m</span>,需要使用所有满足<span class="math inline">\mathrm{prime}_i\leq \sqrt m</span>的<span class="math inline">\mathrm{prime}_i</span>进行筛除,所以计算一个<span class="math inline">h_m</span>的时间为<span class="math inline">\pi(\sqrt m)</span>,其中<span class="math inline">\pi(x)</span>是不超过<span class="math inline">x</span>的素数个数.类似于杜教筛复杂度分析,我们考虑按照<span class="math inline">m=\lfloor\frac{n}{d}\rfloor</span>和<span class="math inline">\sqrt n</span>的大小关系分类进行计算.</p>
<p><span class="math display">
\begin{aligned}
&amp;\pi(n)=\sum_{x\leq n}[x\in \mathrm{prime}]=O(\frac{n}{\log\, n})\\
&amp;T(n)=\sum_{i=1}^{\sqrt n} \pi(\sqrt i)+\sum_{i=1}^{\sqrt n} \pi(\sqrt \frac{n}{i})\\
\\
&amp;\int_0^{\sqrt n} \frac{x}{\log\, x}dx
+\int_0^{\sqrt n} \frac{\sqrt \frac{n}{x}}{\log\sqrt \frac{n}{x}}=O(\frac{n^\frac34}{\log\, n})
\end{aligned}
</span></p>
<p>而另一部分递归求解<span class="math inline">g_{n,1}</span>的复杂度就难以分析了,我们查阅资料时发现国内算法竞赛选手朱震霆研究过这个问题.根据他的研究成果,计算<span class="math inline">g_{n,1}</span>的复杂度是<span class="math inline">O(n^{1-\epsilon})</span>的,是否记忆化<span class="math inline">g</span>并不影响这部分的复杂度,其中<span class="math inline">\epsilon</span>为一大于<span class="math inline">0</span>的小常数,并且发现当<span class="math inline">n</span>较大(达到<span class="math inline">10^{13}</span>以上)时,这个复杂度接近于线性增长,但<span class="math inline">n</span>较小时,可以认为这一部分复杂度是<span class="math inline">O(\frac{n^\frac34}{\log n})</span>的.</p>
<p>稍作总结,这是一个复杂度和线性筛法差不多,但是数据规模小时相较于线性筛法有极大优势的算法.它的理论价值并不高,但可以解决大多数算法竞赛中的数论函数求和问题.</p>
<ul>
<li>类筛法求<span class="math inline">h_n</span>的复杂度为<span class="math inline">O(\frac{n^{\frac34}}{\log\, n})</span>,<span class="math inline">n</span>越大这个上界越紧.</li>
<li>计算<span class="math inline">g</span>这部分是的<span class="math inline">O(n^{1-\epsilon})</span>近线性复杂度,不过<span class="math inline">n\leq 10^{13}</span>时可以认为是<span class="math inline">O(\frac{n^{\frac34}}{\log\, n})</span>.</li>
<li>在<span class="math inline">n\leq 10^{13}</span>时,可以认为<span class="math inline">T(n)=O(\frac{n^\frac34}{\log n})</span>.</li>
</ul>
<h4 id="min_25筛的实现.">2.5.5 min_25筛的实现.</h4>
<p>给出一个可以使用<code>min_25</code>筛求解的题目<a href="https://loj.ac/problem/6053">LOJ 6053</a>.</p>
<p>求<span class="math inline">\sum\limits_{i=1}^n f(i) \bmod (10^9+7)</span>,其中<span class="math inline">n\leq 10^{10}</span>,其中<span class="math inline">f(n)</span>满足是一个数论积性函数,满足以下条件. 1. <span class="math inline">f(1)=1</span> 2. <span class="math inline">f(p^c)=p \oplus c</span> (<span class="math inline">p</span> 为质数，<span class="math inline">\oplus</span> 表示按位异或).</p>
<p>首先<span class="math inline">f(n)</span>在质数处取值是1次多项式;<span class="math inline">n\leq 10^{10}&lt; 2^{64}</span>,所以求<span class="math inline">f(p^c)</span>时,<span class="math inline">p,c&lt; 64</span>可以认为计算<span class="math inline">p\oplus c</span>是<span class="math inline">O(1)</span>的;<span class="math inline">f(n)</span>是积性的,故可以使用<code>min_25</code>筛求<span class="math inline">f(n)</span>的前缀和.我们直接给出c++实现.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> UInt;</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> Int;</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> N=<span class="dv">300000</span>+<span class="dv">10</span>;</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> Int mod=(Int)(<span class="fl">1e9</span>)+<span class="dv">7</span><span class="bu">LL</span>;</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>Int qpow(Int a,Int p){</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(p==<span class="dv">0</span>) <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    Int r=qpow(a,p&gt;&gt;<span class="dv">1</span>);</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    r=r*r%mod;</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (p&amp;<span class="dv">1</span>)?(r*a%mod):r;</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>Int inv2;</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>UInt n;</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> vis[N],prime[N],cnt;</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>Int pre0[N],pre1[N];</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>UInt qwq[N];</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> SQRTN=<span class="dv">0</span>;</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init(){</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;N;i++){</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        pre0[i]=pre0[i-<span class="dv">1</span>];</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        pre1[i]=pre1[i-<span class="dv">1</span>];</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        qwq[i]=qwq[i-<span class="dv">1</span>];</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(!vis[i]){</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            prime[++cnt]=i;</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>            pre0[i]++;</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>            pre1[i]=(pre1[i]+i)%mod;</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;=cnt&amp;&amp;prime[j]*i&lt;N;j++){</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>            vis[i*prime[j]]=<span class="dv">1</span>;</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(i%prime[j]==<span class="dv">0</span>) <span class="cf">break</span>;</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>Int pre0A[N],pre1A[N];</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>Int pre0B[N],pre1B[N];</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> Int&amp; at(UInt x,<span class="dt">int</span> y){</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(x&lt;=SQRTN) <span class="cf">return</span> y?pre1A[x]:pre0A[x];</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y?pre1B[n/x]:pre0B[n/x];</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> Int geth(UInt x){</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    Int ret=<span class="dv">2</span>*(x&gt;=<span class="dv">2</span>);</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(x&lt;N) ret+=( (pre1[x]-pre0[x])%mod );</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> ret+=( (at(x,<span class="dv">1</span>)-at(x,<span class="dv">0</span>))%mod );</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (ret%mod+mod)%mod;</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>Int g(UInt n,<span class="dt">int</span> m){</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    m++; <span class="cf">if</span>(<span class="dv">1</span><span class="bu">ULL</span>*prime[m]&gt;n) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    Int s=<span class="dv">0</span>;</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(m&lt;=cnt&amp;&amp;<span class="dv">1</span><span class="bu">ULL</span>*prime[m]*prime[m]&lt;=n){</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>        UInt p=prime[m],pc=p,c=<span class="dv">1</span>;</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span>(pc&lt;=n){</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>            s=(s+((p^c)%mod)*(<span class="dv">1</span>+g(n/pc,m))%mod)%mod;</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>            c++;pc=pc*p;</span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>        m++;</span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>    Int tmp=((geth(n)-geth(prime[m-<span class="dv">1</span>]))%mod+mod)%mod;</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (s+tmp)%mod;</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> Int s1(Int x){ x%=mod; <span class="cf">return</span> x*(x+<span class="dv">1</span>)%mod*inv2%mod; }</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> Int sub(Int a,Int b){</span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>    a=(a%mod+mod)%mod;</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>    b=((-b)%mod+mod)%mod;</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (a+b)%mod;</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> Int mul(Int a,Int b){</span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>    a=(a%mod+mod)%mod;</span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>    b=(b%mod+mod)%mod;</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a*b%mod;</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>Int solve(){</span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>    UInt l=<span class="dv">1</span>,q=<span class="dv">0</span>;</span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(l&lt;=n){</span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>        q=n/l; l=n/q+<span class="dv">1</span>;</span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>        at(q,<span class="dv">0</span>)=(q-<span class="dv">1</span>);</span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>        at(q,<span class="dv">1</span>)=(s1(q)+mod-<span class="dv">1</span>)%mod;</span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=cnt&amp;&amp;<span class="dv">1</span><span class="bu">ULL</span>*prime[i]*prime[i]&lt;=n;i++){</span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a>        l=<span class="dv">1</span>;q=<span class="dv">0</span>;Int p=prime[i];</span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span>(l&lt;=n){</span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a>            q=n/l; l=n/q+<span class="dv">1</span>;</span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(p*p&gt;q) <span class="cf">break</span>;</span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>            at(q,<span class="dv">0</span>)=sub(at(q,<span class="dv">0</span>),sub(at(q/p,<span class="dv">0</span>),pre0[p-<span class="dv">1</span>]));</span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>            at(q,<span class="dv">1</span>)=sub(at(q,<span class="dv">1</span>),mul(p,sub(at(q/p,<span class="dv">1</span>),pre1[p-<span class="dv">1</span>])));</span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>    Int ret=<span class="dv">1</span>+g(n,<span class="dv">0</span>);</span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret%mod;</span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a>    cin&gt;&gt;n; SQRTN=sqrt(n);</span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>    inv2=qpow(<span class="dv">2</span>,mod-<span class="dv">2</span>);</span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>    init();</span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a>    cout&lt;&lt;solve()&lt;&lt;endl;</span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>这个程序有几个值得注意的地方,<span class="math inline">10^{10}&gt; 2^{32}</span>,<span class="math inline">n^2</span>超过了c++ long long类型(64位有符号整数最大为<span class="math inline">2^{63}-1</span>)的最大值所以判断<span class="math inline">m\leq \sqrt n</span>时应当使用<span class="math inline">n/m\geq m</span>而不是<span class="math inline">m^2\leq n</span>.而对于判断<span class="math inline">\mathrm{prime}_j</span>是否超过<span class="math inline">q</span>可以直接用<span class="math inline">\mathrm{prime}_j^2&gt; q</span>,因为这里用到的质数都是不超过<span class="math inline">\sqrt n</span>的,不会发生溢出.这里<span class="math inline">f(p)=p-1</span>是1次多项式,自然地<span class="math inline">L_{n,1}=\sum_{i=2}^ni=\frac{n(n+1)}{2}-1</span>,对于较高次的情况,可以证明<span class="math inline">S_k(n)=\sum_{i=1}^n i^k</span>是一个<span class="math inline">k+1</span>次多项式,我们可以用拉格朗日插值法<span class="math inline">O(k)</span>求出<span class="math inline">S_k(n)=\sum_{i=0}^{k+1} a_ik^i</span>中的各项系数,进而求出<span class="math inline">L_{n,1}</span>.此外,由于2在模<span class="math inline">10^9+7</span>意义下存在逆元,我们使用费马小定理<span class="math inline">0&lt; a&lt; p,a^{-1}\equiv a^{p-2}\pmod {p}</span>在<span class="math inline">O(\log p)</span>时间内可以求出<span class="math inline">2</span>的逆元,显然<span class="math inline">O(\log p)</span>不超过<span class="math inline">O(\sqrt n)</span>并不会影响<code>min_25</code>筛的复杂度.</p>
<p>此外,这里并没有使用hash表(C++ STL中的<code>unordered_map</code>)存储<span class="math inline">h_n</span>,而是使用了一个小技巧.对于<span class="math inline">h_m</span>,若<span class="math inline">m\leq \sqrt n</span>,将它存储于<span class="math inline">A_{m}</span>处,若<span class="math inline">m&gt; \sqrt n</span>则存储于<span class="math inline">B_{\lfloor\frac{n}{m}\rfloor}</span>处,其中<span class="math inline">A,B</span>是两个长度超过<span class="math inline">\sqrt n</span>的数组.可以证明,这样存储不会发生冲突.从渐进复杂度角度看,hash表和静态数组都是可以<span class="math inline">O(1)</span>存取的,但是实现中,hash表的存取涉及到很多的运算与判断,性能和静态数组差距很大(或者说,同样是<span class="math inline">O(1)</span>,但常数不一样大).需要注意的是用数组代替hash表是一种常数优化而非复杂度优化.</p>
<h2 id="参考文献">3.参考文献</h2>
<ul>
<li><a href="https://www.wikizero.com/en/Mertens%27_theorems">wikipedia:Mertens’ theorems</a></li>
<li><a href="https://www.wikizero.com/en/Dirichlet_convolution">wikipedia:Dirichlet convolution</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32303115">复杂度分析:积性函数的狄利克雷卷积 by 李白天</a></li>
<li>《IOI2018 中国国家候选队论文集》:《一些特殊的数论函数求和问题》by 朱震霆</li>
<li>《2016 年信息学奥林匹克 中国国家队候选队员论文集》:《积性函数求和的几种方法》by 任之洲</li>
</ul>
</body>
</html>
