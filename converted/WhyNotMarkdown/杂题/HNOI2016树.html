<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>HNOI2016树</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="hnoi2016树">[HNOI2016]树</h2>
<h3 id="problem-statement">problem statement</h3>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3248">luogu p3248</a></li>
<li><a href="https://loj.ac/p/2050">LOJ 2050</a></li>
</ul>
<p>给一个<span class="math inline">n</span>点,<span class="math inline">1</span>为根的树,称为模板.<br />
令<span class="math inline">T_0=\mathrm{subtree}(1)</span>,之后进行<span class="math inline">m</span>次操作构造出<span class="math inline">T=T_m</span>.</p>
<p>每次给出<span class="math inline">a,b</span>,其中<span class="math inline">a\leq n,b\leq |T_{i-1}|</span>,用如下操作构造<span class="math inline">T_i</span> 1. 复制<span class="math inline">\mathrm{subtree}(a)</span>,<br />
将其中的节点重新编号为<span class="math inline">|T_{i-1}|+1,|T_{i-1}|+2\dots |T_{i-1}|+|\mathrm{subtree}(a)|</span>,<br />
使得新编号相对大小关系与模板中的相对大小关系不变. 2. 设<span class="math inline">a</span>被重编号为<span class="math inline">a\prime</span>,将这个以<span class="math inline">a\prime</span>为根的树挂到<span class="math inline">T_{i-1}</span>中的<span class="math inline">b</span>下 3. 得到<span class="math inline">T_i</span></p>
<p>之后<span class="math inline">q</span>次询问<span class="math inline">T</span>中两点距离(此处距离定义为,<span class="math inline">T</span>中两点间唯一路径上的边数目).</p>
<p>有<span class="math inline">n,m,q</span>同阶,实际题目中是<span class="math inline">10^5</span>数量级.</p>
<h3 id="solution">solution</h3>
<p>还是<span class="math inline">d(u,v)=d(u)+d(v)-2d\left(\mathrm{LCA}(u,v)\right)</span>,<br />
我们需要做这样一些事情.</p>
<ol type="1">
<li>任意给一个<span class="math inline">T</span>中的编号,计算它到根的距离.</li>
<li>求<span class="math inline">T</span>中两点的LCA.</li>
</ol>
<p>考虑每次操作中复制的<span class="math inline">\mathrm{subtree}(a_i)</span>为一个整体,<br />
求<span class="math inline">LCA(x,y)</span></p>
<ol type="1">
<li><span class="math inline">x,y</span>已经在同一个整体内部,<br />
我们计算一下<span class="math inline">x,y</span>在模板中的编号,<br />
然后在模板树中计算距离即可.</li>
</ol>
<p><span class="math inline">T_0</span>中的点,编号在<span class="math inline">[1,n]</span>,<br />
<span class="math inline">T_1</span>中新增的点,编号在<span class="math inline">[n+1,n+a_1]</span><br />
<span class="math inline">T_2</span>中新增的点,编号在<span class="math inline">[n+a_1+1,n+a_1+a_2]</span><br />
<span class="math inline">T_k</span>中新增的点,编号在<span class="math inline">[1+\sum_{i=0}^{k-1} a_i,\sum_{i=0}^k a_i]</span></p>
<p>对于<span class="math inline">x</span>,我们可以二分,找到它是在<span class="math inline">T_i</span>新增的,对应模板中的<span class="math inline">\mathrm{subtree}(a_i)</span>,<br />
它应当是<span class="math inline">\mathrm{subtree}(a_i)</span>内,编号第<span class="math inline">x-\sum_{j=0}^{i-1} a_j</span>大节点.<br />
子树内计算一个kth,拉出dfs序,变为区间kth,用一个可持久化线段树解决.</p>
<ol start="2" type="1">
<li><span class="math inline">x,y</span>并不再一个整体.<br />
显然会向上爬到一个最近的公共的整体内部,<br />
并且爬到的点一定是构造树<span class="math inline">T</span>时那些做为<span class="math inline">b</span>的点.</li>
</ol>
<p>对于<span class="math inline">T_i</span>我们新建两个点<span class="math inline">r_i,u_i</span>,<br />
分别表示复制出来的<span class="math inline">\mathrm{subtree}(a_i)</span>的根,以及<span class="math inline">b_i</span>.<br />
二分得到<span class="math inline">b_i</span>是<span class="math inline">T_k</span>中新增的,则连出这些边<span class="math inline">(a_k\to b_i,d),(b_i\to a_i,1)</span>其中<span class="math inline">d</span>是<span class="math inline">a_k</span>和<span class="math inline">b_i</span>的距离.<br />
在这样一个树上,很容易找到<span class="math inline">x,y</span>向上走到某个整体时接入的点(某个<span class="math inline">b</span>),然后就转换成为了case 1.</p>
<p>具体实现还要进一步思考.</p>
<ul>
<li>首先是给出<span class="math inline">k</span>,求解到根的距离,在这样构造的树上面,找到<span class="math inline">k</span>对应的整体<span class="math inline">a_k</span>, 距离由两部分构成,一部分是根走到<span class="math inline">a_k</span>,令一部分是<span class="math inline">a_k</span>到<span class="math inline">k</span>,都很好计算.</li>
<li>然后是LCA计算, 首先考虑<span class="math inline">x,y</span>对应的那个整体的根<span class="math inline">a_x,a_y</span>,<br />
我们直接在新树求<span class="math inline">\mathrm{LCA}(a_x,a_x)</span>
<ol type="1">
<li>落在<span class="math inline">a_x,a_y</span>中的一个,不失一般性,设落在<span class="math inline">a_y</span>,<br />
我们可以知道,<span class="math inline">x,y</span>的实际LCA应该是<span class="math inline">a_y</span>对应的树内部.<br />
找到<span class="math inline">a_x</span>向上跳到<span class="math inline">a_y</span>过程中的最后一步所在的点,设为<span class="math inline">t</span>,则<span class="math inline">t</span>与<span class="math inline">y</span>在<span class="math inline">a_y</span>内部的LCA即为所求.</li>
<li>落在一个<span class="math inline">a_z</span>上,我们找到<span class="math inline">a_x,a_y</span>向上跳到<span class="math inline">a_z</span>的前一步对应的点,设为<span class="math inline">b_x,b_y</span>.这两个点在<span class="math inline">a_z</span>内部的LCA就是答案.</li>
<li>没有其他情况.</li>
</ol></li>
</ul>
<p>当然,这个题目不强制在线做法, 可以把查询中的<span class="math inline">x,y</span>也按照构造新树的方法,做为伪<span class="math inline">b</span>节点,可以省掉一些讨论.</p>
<h3 id="code">code</h3>
<p>总体来说,不是很难写…<br />
但是请务必用合适的identifier或者type来标识不同意义的东西…不然很容易写出来什么 “编号与深度做减法” 的明显语义不对的程序.<br />
当然这可以考peer review或者“小黄鸭debug”(向它人解释“思路和实现的对应关系”,借此找出mismatch的code)解决,但是</p>
<p>issues that can be detected during coding stage or compiling stage shouldn’t be put off until debugging stage.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Int=<span class="dt">signed</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Int read(){</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    Int x=<span class="dv">0</span>;<span class="dt">char</span> c;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">do</span>{c=getchar();}<span class="cf">while</span>(!isdigit(c));</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">do</span>{x=x*<span class="dv">10</span>+c-<span class="ch">&#39;0&#39;</span>;c=getchar();}<span class="cf">while</span>(isdigit(c));</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> N=<span class="dv">100000</span>+<span class="dv">10</span>;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> LogN=<span class="dv">20</span>;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> M=N*LogN;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n,m,root[N]; Int pre[N];</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> T0{ <span class="co">// template tree</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; g[N];</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fa[N],sz[N],dep[N],son[N];</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> idx,dfn[N],top[N];</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt,ch[M][<span class="dv">2</span>],sm[M],tree[N];</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> add(<span class="dt">int</span> o,<span class="dt">int</span> L,<span class="dt">int</span> R,<span class="dt">int</span> p){</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x=++cnt; sm[x]=sm[o]+<span class="dv">1</span>;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        ch[x][<span class="dv">0</span>]=ch[o][<span class="dv">0</span>];ch[x][<span class="dv">1</span>]=ch[o][<span class="dv">1</span>];</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(L&lt;R){</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> mid=(L+R)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(p&lt;=mid) ch[x][<span class="dv">0</span>]=add(ch[o][<span class="dv">0</span>],L,mid,p);</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> ch[x][<span class="dv">1</span>]=add(ch[o][<span class="dv">1</span>],mid+<span class="dv">1</span>,R,p);</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x;</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> kth(<span class="dt">int</span> o1,<span class="dt">int</span> o2,<span class="dt">int</span> L,<span class="dt">int</span> R,<span class="dt">int</span> k){</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(L==R) <span class="cf">return</span> L;</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> mid=(L+R)&gt;&gt;<span class="dv">1</span>,s=sm[ch[o2][<span class="dv">0</span>]]-sm[ch[o1][<span class="dv">0</span>]];</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(k&lt;=s) <span class="cf">return</span> kth(ch[o1][<span class="dv">0</span>],ch[o2][<span class="dv">0</span>],L,mid,k);</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> kth(ch[o1][<span class="dv">1</span>],ch[o2][<span class="dv">1</span>],mid+<span class="dv">1</span>,R,k-s);</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> subtree_kth(<span class="dt">int</span> u,<span class="dt">int</span> k){</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> l=dfn[u],r=dfn[u]+sz[u]-<span class="dv">1</span>;</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> kth(tree[l-<span class="dv">1</span>],tree[r],<span class="dv">1</span>,n,k);</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> dfs1(<span class="dt">int</span> u,<span class="dt">int</span> f){</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        sz[u]=<span class="dv">1</span>; dep[u]=dep[fa[u]=f]+<span class="dv">1</span>;</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(u==f) dep[u]=<span class="dv">0</span>;</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> v:g[u]) <span class="cf">if</span>(v!=f){</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>            dfs1(v,u); sz[u]+=sz[v];</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(sz[son[u]]&lt;sz[v]) son[u]=v;</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> dfs2(<span class="dt">int</span> u,<span class="dt">int</span> f){</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        dfn[u]=++idx; top[u]=f;</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        tree[idx]=add(tree[idx-<span class="dv">1</span>],<span class="dv">1</span>,n,u);</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(son[u]) dfs2(son[u],f);</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> v:g[u]) <span class="cf">if</span>(dfn[v]==<span class="dv">0</span>) dfs2(v,v);</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> lca(<span class="dt">int</span> u,<span class="dt">int</span> v){</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span>(top[u]!=top[v]){</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="bu">std::</span>swap(u,v);</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>            u=fa[top[u]];</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(dep[u]&gt;dep[v]) <span class="bu">std::</span>swap(u,v);</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> u;</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dis(<span class="dt">int</span> u,<span class="dt">int</span> v){ <span class="cf">return</span> dep[u]+dep[v]-<span class="dv">2</span>*dep[lca(u,v)]; }</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init(){ dfs1(<span class="dv">1</span>,<span class="dv">1</span>); dfs2(<span class="dv">1</span>,<span class="dv">1</span>); }</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> T1{ <span class="co">// big tree</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> V=N*<span class="dv">2</span>;</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;&gt; sub[V];</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> anc[V][LogN],len[V];</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    Int dep[V];</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> dfs(<span class="dt">int</span> u,<span class="dt">int</span> f){</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        anc[u][<span class="dv">0</span>]=f;</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;LogN;i++)anc[u][i]=anc[anc[u][i-<span class="dv">1</span>]][i-<span class="dv">1</span>];</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="kw">auto</span> [v,w]:sub[u]){</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>            dep[v]=dep[u]+w; len[v]=len[u]+<span class="dv">1</span>;</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>            dfs(v,u);</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> lca(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(len[x]&lt;len[y]) <span class="bu">std::</span>swap(x,y);</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=LogN-<span class="dv">1</span>;i&gt;=<span class="dv">0</span>;i--){</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> xx=anc[x][i];</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(len[xx]&gt;=len[y]) x=xx;</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(x==y) <span class="cf">return</span> x;</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=LogN-<span class="dv">1</span>;i&gt;=<span class="dv">0</span>;i--){</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> xx=anc[x][i],yy=anc[y][i];</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(xx!=yy){ x=xx;y=yy; }</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> anc[x][<span class="dv">0</span>];</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init(){ dfs(<span class="dv">0</span>,<span class="dv">0</span>); }</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; restore(Int x,<span class="dt">int</span> lim){</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(x&lt;=n) <span class="cf">return</span> <span class="bu">std::</span>make_pair(<span class="dv">0</span>,x);</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> blk=<span class="bu">std::</span>lower_bound(pre+<span class="dv">0</span>,pre+lim+<span class="dv">1</span>,x)-pre;</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>make_pair(blk,T0::subtree_kth(root[blk],x-pre[blk-<span class="dv">1</span>]));</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> tag[N&lt;&lt;<span class="dv">2</span>];</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>    n=read();m=read();  <span class="dt">int</span> q=read();</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;n;i++){</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a=read(),b=read();</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>        T0::g[a].push_back(b);</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>        T0::g[b].push_back(a);</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>    } T0::init();</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>    root[<span class="dv">0</span>]=<span class="dv">1</span>;pre[<span class="dv">0</span>]=n;</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=m;i++){</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> r=root[i]=read(); pre[i]=pre[i-<span class="dv">1</span>]+T0::sz[r];</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> [fb,fv]=restore(read(),i-<span class="dv">1</span>);</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> mid=m+i; tag[mid]=fv;</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>        T1::sub[fb].push_back(<span class="bu">std::</span>make_pair(mid,T0::dep[fv]-T0::dep[root[fb]]));</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>        T1::sub[mid].push_back(<span class="bu">std::</span>make_pair(i,<span class="dv">1</span>));</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>    } T1::init();</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(q--){</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> _x=read(),_y=read();</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> [bx,ix]=restore(_x,m);</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> [by,iy]=restore(_y,m);</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>        Int ans=<span class="dv">0</span>;</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(bx==by) ans=T0::dis(ix,iy);</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>{</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>            ans=T0::dep[ix]-T0::dep[root[bx]]</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>                +T0::dep[iy]-T0::dep[root[by]]</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>                +T1::dep[bx]+T1::dep[by];</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> x=bx,y=by,ll=T1::lca(x,y);</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(ll==x||ll==y){</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span>(ll==x){ <span class="bu">std::</span>swap(bx,by); <span class="bu">std::</span>swap(ix,iy); <span class="bu">std::</span>swap(x,y); }</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span>(<span class="dt">int</span> i=LogN-<span class="dv">1</span>;i&gt;=<span class="dv">0</span>;i--){</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">int</span> xx=T1::anc[x][i];</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span>(T1::len[xx]&gt;T1::len[ll]) x=xx;</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>                }</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> lca=T0::lca(tag[x],iy);</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>                ans-=<span class="dv">2</span>*(T1::dep[ll]+T0::dep[lca]-T0::dep[root[ll]]);</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>            }<span class="cf">else</span>{</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span>(<span class="dt">int</span> i=LogN-<span class="dv">1</span>;i&gt;=<span class="dv">0</span>;i--){</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">int</span> xx=T1::anc[x][i],yy=T1::anc[y][i];</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span>(T1::len[xx]&gt;T1::len[ll]) x=xx;</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span>(T1::len[yy]&gt;T1::len[ll]) y=yy;</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>                }</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> lca=T0::lca(tag[x],tag[y]);</span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>                ans-=<span class="dv">2</span>*(T1::dep[ll]+T0::dep[lca]-T0::dep[root[ll]]);</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,ans);</span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</body>
</html>
